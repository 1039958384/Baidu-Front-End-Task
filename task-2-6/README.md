#排序算法的可视化呈现
[Demo](http://1039958384.github.io/IFE/task-2-6/)
## 任务描述
* 基于task-2-5;
* 限制输入的数字在10-100;
* 队列元素数量最多限制为60个，当超过60个时，添加元素时alert出提示;
* 队列展现方式变化[如图](http://7xrp04.com1.z0.glb.clouddn.com/task_2_19_1.jpg)，直接用高度表示数字大小;
* 实现一个简单的排序功能，如冒泡排序（不限制具体算法），用可视化的方法表达出来。

## 随机数产生算法

## 排序算法总结
### 冒泡排序
比较任何两个相邻的项，如果第一个比第二个大，则交换它们。元素项向上移动到正确的顺序，就像气泡升至表面一样，冒泡排序因此得名。<br>
冒泡排序的时间复杂度为 O(n^2)

### 选择排序
找到数据结构中的最小值并将其放在第一位，接着找到第二小的值并将其放在第二位，以此类推。<br>
选择排序同样也是一个复杂度为 O(n^2) 的算法。

### 插入排序
插入排序每次排一个数组项，以此方式构建最后的排序数组。<br>
假定第一项已经排序了，接着，它和第二项进行比较，第二项是应该待在原位还是插到第一项之前呢？这样，头两项就已正确排序，<br>
接着和第三项比较（它是该插入到第一、第二还是第三的位置呢？），以此类推。<br>

排序小型数组时，插入排序比选择排序和冒泡排序性能要好

### 归并排序
归并排序是第一个可以被实际使用的排序算法。其复杂度为O(nlogn)。<br>

归并排序是一种分治算法(也是递归的)。其思想是将原始数组切分成较小的数组，直到每个小数组只有一个位置，接着将小数组归并成较大的数组，直到最后只有一个排序完毕的大数组。<br>


### 快速排序

快速排序也许是最常用的排序算法了。它的复杂度为O(nlogn)。<br>
它的性能通常比其他的复杂度为O(nlogn)的排序算法要好。<br>
和归并排序一样，快速排序也使用分治的方法，将原始数组分为较小的数组（但它没有像归并排序那样将它们分割开）。<br>

*  首先，从数组中选择中间一项作为主元。
*  创建两个指针，左边一个指向数组第一个项，右边一个指向数组最后一个项。移动左指
针直到我们找到一个比主元大的元素，接着，移动右指针直到找到一个比主元小的元素，然后交
换它们，重复这个过程，直到左指针超过了右指针。这个过程将使得比主元小的值都排在主元之
前，而比主元大的值都排在主元之后。这一步叫作划分操作。
*  接着，算法对划分后的小数组（较主元小的值组成的子数组，以及较主元大的值组成的
子数组）重复之前的两个步骤，直至数组已完全排序。

